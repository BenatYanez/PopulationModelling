#Discrete Model
#Parameters r and K
#Create the discrete model function with two para,eters r and K and the population size
discretePop_function <- function(r,p,k) {
  z <-  r*(1-(p/k))*p+p
  return(z)
}
#Set initial parameters
startPop<-10
growthRate<- 2.1
carryCap<-100
discretePop_function(growthRate,startPop,carryCap)

steps<- 1:500
results<-numeric(500)
resultsPlusOne<-numeric(500)

#Loop the function for 500 steps

for (i in steps)
{
  results[i] <- startPop
  startPop <- discretePop_function(growthRate,results,carryCap)
}
startPop<- 10
for (i in steps)
{
  startPop <- discretePop_function(growthRate,startPop,carryCap)
  resultsPlusOne[i] <- startPop
}
#Results represents p(t)
plot(results)

#Plot using dots
plot(results, resultsPlusOne, xlab= "P(t)", ylab="P(t+1)")
vals<- seq(0,150,0.1) 
#Plot using a line
plot(results, resultsPlusOne, xlab= "P(t)", ylab="P(t+1)")
lines(x=vals,y=growthRate*(1-(vals/carryCap))*vals+vals, col="blue")
lines(x=0:150,y=0:150, col="red")
#Or a different way to the curve of the equation
curve(growthRate*(1-(x/carryCap))*x+x, from=0, to=400)

#Continuos Model
library(ggplot2)
library(tidyverse)
library(deSolve)

state <- c(P=10)
times <- seq(0,100,by=0.01)
parameters  <- c(r=0.1,K=1000)
LogGrowth  <- function(t,state,parameters){
  #Log growth function that atkes a set of parameter values intial conditions and a time sequence
  with(as.list(c(state,parameters)),{
    #with is a function that allows us to use the variable name directly- looks for K,r and P in state and parameters
    dP  <- r*(1-P/K)*P #The logistic equation
    return(list(dP)) #return the rate of change, needs to be a list
    
  })
}
out  <- ode(y=state, times=times,func=LogGrowth, parms= parameters)
#Transform the deSolve data into a data frame
out_dataframe  <- data.frame(out)
plot(out_dataframe, type="l")
ggplot(data=out_dataframe) +
  geom_line(mapping=aes(x=time,y=P),color="blue")+
  geom_hline(yintercept = 0, color="darkgrey") +
  geom_vline(xintercept = 0, color="darkgrey") +
  labs(x="Time",y="p")

#Model calibration


tmax   <- 200 #To estimate r we only need the initial increase in population
x  <- numeric(tmax+1)
for(i in 2:(tmax+1)) {
  x[i]   <- r*x[i-1]*(1-x[i-1]/K)+x[i-1]+rnorm (1,0,x[i-1]/100)
}
#Calibrate using a population with small amounts of stochasticity
simulationSmall <- read.csv("pop_LG_simul_noise_small.csv")
PopulationInitial <- simulationSmall[1,2]
plot(simulationSmall)
K <- mean(simulationSmall[100:300,2])
#Inverse model to figure out parameter r
out_df_list <- list()#Create a list to store the model outputs for the different values of r
i <- 1 #Used to keep track of indixes in out_df_list
for(r in seq(0.01,1,0.01)) { #vary r from 0.01 to 1 by steps of 0.01
  parameters  <- c(r=r, K=K) #These are the parameters as before
  state  <- c(P=simulationSmall$P[1]) #Initial population value
  times  <- seq (0,tmax, by=1) #this is the time steps We want a value each time step to match how data was generated
  out <- ode(y=state, times=times, func=LogGrowth,parms=parameters)
  out_df_list[[i]]  <- data.frame(out) #we store the dataframe
  i  <- i+1
}
#Out_df_list now is a list containing dataframes with the population size for each value of r

fit  <- numeric(length(out_df_list))
for(i in 1:length(out_df_list)) {
  fit[i]  <- sum(abs(out_df_list[[i]]$P-simulationSmall$P[1:(tmax+1)])) #FOr each dataframe do pop at time 1 - pop at time 1 in the simulation, do that for all the times and add them togetehr as aboslute numbers (i.e ignoring negatives)
  #Do this for every dataframe in the list to find which has the smallest difference between dataframe and simulation
}

ind_est  <- which.min(fit) #Which is the minimum number in the fit
seq(0.01,1,0.01)[which.min(fit)]
ind_real   <- which (seq(0.01,1,0.01)==0.2)

#Plot values generated by estimate and and the real r values
colors   <- c("Estimated"="red","Real"="cyan4")
ggplot() +
  geom_line(mapping=aes(x=0:tmax,y=simulationSmall$P[1:(tmax+1)])) +
  geom_line(mapping=aes(x=0:tmax,y=out_df_list[[ind_est]]$P, color="Estimated")) +
  geom_line(mapping=aes(x=0:tmax, y=out_df_list[[ind_real]]$P, color="Real")) +
  geom_hline(yintercept=0, color="darkgrey") +
  geom_vline(xintercept = 0, color="darkgrey") +
  xlim(0,tmax*1.1) +
  ylim(0,K+100) +
  labs(x="Time", y="P", color ="Legend") +
  scale_color_manual(values=colors)

#Calibrate using population with large amount of stochasticity
simulationBig <- read.csv("pop_LG_simul_noise_big.csv")
PopulationInitialBig <- simulationBig[1,2]
plot(simulationBig)
KBig <- mean(simulationBig[50:300,2])
out_df_list_big <- list()#Create a list to store the model outputs for the different values of r
l <- 1 #Used to keep track of indixes in out_df_list
for(R in seq(0.01,1,0.01)) { #vary r from 0.01 to 1 by steps of 0.01
  parameters  <- c(r=R, K=KBig) #These are the parameters as before
  state  <- c(P=simulationBig$P[1]) #Initial population value
  times  <- seq (0,tmax, by=1) #this is the time steps We want a value each time step to match how data was generated
  out <- ode(y=state, times=times, func=LogGrowth,parms=parameters)
  out_df_list_big[[l]]  <- data.frame(out) #we store the dataframe
  l  <- l+1
}
fitBig  <- numeric(length(out_df_list_big))
for(x in 1:length(out_df_list_big)) {
  fitBig[x]  <- sum(abs(out_df_list_big[[x]]$P-simulationBig$P[1:(tmax+1)])) #FOr each dataframe do pop at time 1 - pop at time 1 in the simulation, do that for all the times and add them togetehr as aboslute numbers (i.e ignoring negatives)
  #Do this for every dataframe in the list to find which has the smallest difference between dataframe and simulation
}
ind_est_big  <- which.min(fitBig) #Which is the minimum number in the fit
seq(0.01,1,0.01)[which.min(fitBig)]
ind_real_big   <- which (seq(0.01,1,0.01)==0.2)
colors   <- c("Estimated"="red","Real"="cyan4")
ggplot() +
  geom_line(mapping=aes(x=0:tmax,y=simulationBig$P[1:(tmax+1)])) +
  geom_line(mapping=aes(x=0:tmax,y=out_df_list_big[[ind_est_big]]$P, color="Estimated")) +
  geom_line(mapping=aes(x=0:tmax, y=out_df_list_big[[ind_real_big]]$P, color="Real")) +
  geom_hline(yintercept=0, color="darkgrey") +
  geom_vline(xintercept = 0, color="darkgrey") +
  xlim(0,tmax*1.1) +
  ylim(0,K+100) +
  labs(x="Time", y="P", color ="Legend") +
  scale_color_manual(values=colors)

#Bifurcation Plot
Pop <- numeric(500)
Pop[1]   <- 10
k   <- 100
out_list <- list()
out2_matrix <- matrix(NA,ncol=2,nrow=0)
l <- 1

for (r in seq(0.1, 3, 0.02)) {
  for( i in 2:500){
    Pop[i] <-   r*(1-(Pop[i-1]/k))*Pop[i-1]+ Pop[i-1]
  }
  out <- list(tail(Pop,50))
  out_list[[l]] <- data.frame(x=r,y=out) #Not really necessary
  
  out2 <-tail(Pop,50)
  out2_matrix <- rbind(out2_matrix,data.frame(x=rep(r,50),y=out2))
  l <- l+1
}
ggplot(out2_matrix, aes(x=x, y=y)) + geom_point (size=0.5)+
  xlim(0,3*1.02) +
  ylim(0,max(out2_matrix)+10) +
  geom_hline(yintercept=0, color="darkgrey") +
  geom_vline(xintercept = 0, color="darkgrey") +
  labs(x="Growth rate", y="Population")
